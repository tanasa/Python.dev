#!/usr/bin/env python
# coding: utf-8

# In[1]:


print("Abstract methods:")


# In[2]:


# You import ABC and abstractmethod from the abc module (abc = Abstract Base Classes).
# ABC is a special base class that enables you to create abstract classes in Python


# In[3]:


print('''

What is an Abstract Method?

An abstract method is a method declared in a base class (with @abstractmethod) but not implemented there.

It forces subclasses to provide their own version of the method.

If a subclass does not implement all abstract methods, it cannot be instantiated.

In short:

An abstract method defines "this method must exist" but doesn't define how it works.

''')


# In[ ]:





# In[4]:


from abc import ABC, abstractmethod

class Foo(ABC):
    def method1(self):
        return 'method1'

    def call_method2(self):
        # dynamic binding
        print(self.method2())

    @abstractmethod
    def method2(self):
        return NotImplemented


# Foo inherits from ABC, making it an abstract base class.
# It means you cannot instantiate Foo directly unless you implement all its abstract methods in a subclass.

# call_method2 calls self.method2().
# Dynamic binding here means that the actual version of method2 called will depend on the subclass's implementation, 
# even though you are calling it from the base class (Foo).

class Bar(Foo):
    def method2(self):
        return 'method2 from Bar'

# method2 is marked as an abstract method using the @abstractmethod decorator.
# Abstract methods must be implemented in any subclass before instantiation.
# Returning NotImplemented is just a convention to signal that it's not actually implemented yet

if __name__ == '__main__':
    b = Bar()
    print(b.method1())
    print(b.method2())
    b.call_method2()


# In[ ]:





# In[5]:


print("Multiple inheritance")


# In[6]:


class Animal:
    number_of_animals = 0

    def __init__(self, name):
        self._name = name
        Animal.number_of_animals += 1


class Dog(Animal):
    def __init__(self, name, breed, color):
        Animal.__init__(self, name)
        self._breed = breed
        self._color = color

    def _get_color(self):
        return self._color

    color = property(fget=_get_color)


class Domestic(Animal):
    def __init__(self, name, address):
        Animal.__init__(self, name)
        self._address = address

    def _get_address(self):
        return self._address

    address = property(fget=_get_address)

# HomePuppy: A subclass that inherits from both Dog and Domestic.
# Multiple inheritance: HomePuppy inherits from both Dog and Domestic.
# You manually call Dog.__init__ and Domestic.__init__.

class HomePuppy(Dog, Domestic):
    def __init__(self, name, breed, color, address):
        # super().__init__(name, breed, color, address)
        Dog.__init__(self, name, breed, color)
        Domestic.__init__(self, name, address)


if __name__ == '__main__':
    p = HomePuppy('John', 'Chihuahua', 'brown', 'San Jose')
    print(p.color)
    print(p.address)
    print(Animal.number_of_animals)
    print(HomePuppy.__mro__)

# The method resolution order (__mro__).
# Python will look first in HomePuppy, then Dog, then Domestic, then Animal, then object.

print('''

Multiple Inheritance Issue:

You manually call Dog.__init__ and Domestic.__init__.
Both of those call Animal.__init__.
Result: Animal.number_of_animals increments twice for the same puppy object (actually even thrice overall when HomePuppy is created).
This causes duplicate initialization.

Why was super() commented? Example using super() correctly:

''')


# In[7]:


print("Version of the code generated by GPT4:")

# Why does this work now?

# super() passes all arguments (name, breed, color, address) as a dictionary.
# Every class picks only what it needs and forwards the rest up the chain.
# Animal's __init__ is called only once, so number_of_animals == 1.
# No missing arguments for any parent class.

class Animal:
    number_of_animals = 0

    def __init__(self, name, **kwargs):
        self._name = name
        Animal.number_of_animals += 1
        super().__init__(**kwargs)

class Dog(Animal):
    def __init__(self, breed, color, **kwargs):
        self._breed = breed
        self._color = color
        super().__init__(**kwargs)

    @property
    def color(self):
        return self._color

class Domestic(Animal):
    def __init__(self, address, **kwargs):
        self._address = address
        super().__init__(**kwargs)

    @property
    def address(self):
        return self._address

class HomePuppy(Dog, Domestic):
    def __init__(self, name, breed, color, address):
        super().__init__(name=name, breed=breed, color=color, address=address)

if __name__ == '__main__':
    p = HomePuppy('John', 'Chihuahua', 'brown', 'San Jose')
    print(p.color)           # 'brown'
    print(p.address)         # 'San Jose'
    print(Animal.number_of_animals)  # 1
    print(HomePuppy.__mro__)


# In[8]:


# If you want it even simpler, even no multiple inheritance, you can do:

class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed, color):
        super().__init__(name)
        self.breed = breed
        self.color = color

class HomePuppy(Dog):
    def __init__(self, name, breed, color, address):
        super().__init__(name, breed, color)
        self.address = address


# In[ ]:





# In[ ]:





# In[9]:


print("Version of the code presented in the class:")

class Animal:
    number_of_animals = 0

    def __init__(self, name, **info):
        super().__init__(**info)
        self.name = name
        Animal.number_of_animals += 1


class Dog(Animal):
    def __init__(self, breed, color, **info):
        super().__init__(**info)
        self._breed = breed
        self._color = color

    def _get_color(self):
        return self._color

    color = property(fget=_get_color)


class Domestic(Animal):
    def __init__(self, address, **info):
        super().__init__(**info)
        self._address = address

    def _get_address(self):
        return self._address

    address = property(fget=_get_address)


class HomePuppy(Dog, Domestic):
    def __init__(self, **info):
        super().__init__(**info)


if __name__ == '__main__':
    
    p = HomePuppy(name='John', breed='Chihuahua', color='brown', address='San Jose')
    print(p.color)
    print(p.address)
    print(Animal.number_of_animals)
    print(HomePuppy.__mro__)


# In[ ]:





# In[10]:


print("Keyword Parameters demo:")


# In[11]:


print('''

Meaning of * and ** in Functions:

Symbol	Name	What it does
*	"args"	Collects any extra positional arguments into a tuple
**	"kwargs"	Collects any extra keyword arguments into a dictionary

âœ… You can also use * and ** to unpack values when calling a function!

''')

def mystery(a, *items):
    print(a)
    print(items)


mystery(1, 2, 3)

def magic(yellow, **colors):
    print(yellow)
    print(colors)

magic(yellow=1, red=2, blue=3, pink=4)

def magic2(name, age, school):
    print(name, age, school, sep=':')

info = {'name': 'John', 'age': 20, 'school': 'Stanford'}
magic2(**info)

print('''

list	Unpack a list when calling a function	f(*[1,2,3])
**dict	Unpack a dictionary into keyword arguments when calling a function	f(**{'a':1, 'b':2}

''')


# In[12]:


print('''

âœ¨ You can think like this:

* â†’ "bundle extra arguments into a tuple" (inside function)

* â†’ "spread a tuple into arguments" (when calling function)

** â†’ "bundle extra keyword arguments into a dictionary" (inside function)

** â†’ "spread a dictionary into keyword arguments" (when calling function)

''')


# In[13]:


def example(a, b, *args, **kwargs):
    print('a =', a)
    print('b =', b)
    print('args =', args)
    print('kwargs =', kwargs)

example(1, 2, 3, 4, 5, x=10, y=20)


# In[14]:


print('''

ðŸ§  One-Line Definition:

*args is for extra unnamed things.
**kwargs is for extra named things.

''')


# In[15]:


def make_pizza(size, *toppings):
    print(f"Making a {size}-inch pizza with:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza(12, "pepperoni", "cheese", "olives")


# In[ ]:




